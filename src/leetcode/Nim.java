package leetcode;

/*
 * 你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

 * 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。
 */
public class Nim {
	public boolean canWinNim(int n) {
		boolean flag = false;
		if (n % 4 != 0) {
			flag = true;
		}
		return flag;
	}
}
/**
 * 这里做一个抽象，假设一堆里面有n个石头，每次可以取 1-m 个石头。
 * 
 * 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。这里我们就有一个想法了，
 * 假设这个石头堆为 (m+1)的倍数，那么第一个人取k( 1 <= k <= m)个，只要第二个人取
 * (m+1-k)个石头，那么必定状态能回到最初的状态，m+1个。因为每个人都是很聪明的，取的石头的个数一定要对自己有利。那么，假设最初石头堆不为
 * (m+1)的倍数。n=（m+1）r+s，那么第一个人只要取s个石头必定能获得胜利，反之，如果s == 0 ，那么第一个人必输。
 * 
 * 
 * 即，若n=k*(m+1)，则后取着胜，反之，存在先取者获胜的取法。n%(m+1)==0. 先取者必败。
 */
